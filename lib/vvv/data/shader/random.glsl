//  Copyright (C) 2024, Max Piochowiak and Reiner Dolp, Karlsruhe Institute of Technology
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.

#ifndef RANDOM_GLSL
#define RANDOM_GLSL

#include "util.glsl"
#include "pcg_hash.glsl"

// RANDOM NUMBERS ------------------------------------------------------------------------------------------------------

// returns a random normalized 2D direction
vec2 randomDirection2(uvec2 v) {
    return normalize(vec2(hash_pcg2d(v)) - vec2(~0u / 2u));
}

// returns a random vec3 in the [0, 1) interval.
// xy from thread ID, feedback one of the result components to the next random query as seed
vec3 randomVec3(const ivec2 xy, const in uint seed) {
    return vec3(hash_pcg3d((uvec3(xy, seed)))) / float(0xffffffffU);
}

// returns a random vec3 in the [0, 1) interval and updates the seed.
// xy from thread ID, overwrites seed with the .z compontent of the returned RNG value.
vec3 nextRNG(const in ivec2 xy, inout uint seed) {
    uvec3 r = hash_pcg3d(uvec3(xy, seed));
    seed = r.z;
    return vec3(r) / float(0xffffffffU);
}


// SAMPLING ------------------------------------------------------------------------------------------------------------
vec2 sampleUniformDisc(const in vec2 u) {
    float r = sqrt(u.x);
    float theta = TWO_PI * u.y;
    return vec2(r * cos(theta), r * sin(theta));
}

vec2 sampleBlackmanHarris(const vec2 u) {
    const vec2 res = vec2(cos(u.y * PI * 2.f), sin(u.y * PI * 2.f));
    // surprisingly good fit to inverse cdf
    const float r = 0.943404f * asin(0.636617f * asin(sqrt(u.x)));
    return res * r;
}

vec3 sampleUniformSphere(const in vec2 u) {
    const float h = 1.f - 2.f * u.x;
    const float r = sqrt(1.f - h * h);
    return vec3(r * cos(2.f * PI * u.y), h, r * sin(2.f * PI * u.y));
}

vec3 sampleUniformHemisphereVoxel(const in vec2 u, const in vec3 normal) {
    const vec3 dir = sampleUniformSphere(u);
    // Assuming that the normal is axis-oriented, we only have to alter the sign of dir's components to project it into
    // the positive hemisphere. This is the case for surface normals of voxels.
    // note: sign(dot(n,d)) does not work for the singularities when one component is zero (sign returns 0 instead of 1)
    //       this is the case for directions from sampleUniformSphere(u) that lie in the xz plane.
    return dot(normal, dir) < 0.f ? -dir : dir;
}

float pdfUniformHemisphere(const in vec3 dir, const in vec3 normal) {
    return ONE_OVER_TWO_PI;
}

vec3 sampleCosineWeightedHemisphereVoxel(const in vec2 u, in vec3 normal) {
    float r = sqrt(u.x);
    float theta = 2.0 * PI * u.y;

    // Assuming that the normal is axis-oriented, the vector (1, 0, 1) is always valid
    const vec3  bitangent = normalize(cross(normal, vec3(1.f, 0.f, 1.f)));
    const vec3  tangent = cross(bitangent, normal);

    return normalize(r * sin(theta) * bitangent + sqrt(1.0 - u.x) * normal + r * cos(theta) * tangent);;
}

float pdfCosineWeightedHemisphere( const in vec3 dir, const in vec3 normal) {
    return dot(dir, normal) * ONE_OVER_PI;
}


// NOISE ---------------------------------------------------------------------------------------------------------------

#define USE_PACKED_BLUE_NOISE

// CC0 tilable 32x32 blue noise from Christoph Peters (http://momentsingraphics.de/BlueNoise.html)
#ifdef USE_PACKED_BLUE_NOISE
const int _packedBlueNoise32x32[256] = {
0xf5daa799, 0xe4d2c394, 0x3b23f28c, 0x96f92fd, 0x5f3979f8, 0x3de7be4e, 0x69421272, 0x495fc090, 0xb13957fb, 0x6e174c79,
0x77d6a242, 0x41da2c5a, 0xe215a689, 0x287fd62e, 0x52b399f2, 0x7c11d405, 0x2c106f24, 0x83ac07ea, 0xaf0953bf, 0x21bde685,
0x93c3ebb2, 0x8ca41c75, 0xdb20c85b, 0xb93e87ee, 0x8ad0e092, 0x28d99b62, 0xee981dfa, 0x64a04a10, 0x46690152, 0x853b0ff,
0xa17e33df, 0xe7aa2c71, 0x4050be19, 0x3958f4c7, 0x34c96276, 0x7e19cd6c, 0xcc8535d3, 0xbfed3a0e, 0x16fc436d, 0x6858cc4b,
0x73aa0282, 0x910cb51c, 0xb647e0a8, 0xe23cf88d, 0x25b8f697, 0x91d0639d, 0xc461a913, 0x35f40a96, 0xe596fa47, 0xeb4a7c31,
0x248002d1, 0x75ab065e, 0x7057132b, 0x2d794ade, 0x29e984b5, 0x9edcb28a, 0xd6265dc9, 0x18c6a365, 0xe8a02f6a, 0xc54b93c1,
0xafe9a160, 0x1ef30489, 0xd4004ee1, 0x78206b3f, 0x9b83beb, 0x863df88f, 0x3ffd51bd, 0xf2de1d71, 0x19d5410b, 0x95a6c636,
0x7abc375a, 0x11c154f0, 0x52846fa8, 0x215bce15, 0xd71298af, 0x823357b1, 0x50798eba, 0xd84368f9, 0x609af672, 0x8e31a40d,
0xe9dc1dd1, 0xef702dad, 0x886078df, 0x229dce0b, 0x9b2dcc67, 0xa8025bb, 0x25ad14c3, 0x4cffe183, 0x449a652b, 0x49ec07a,
0x2ac43647, 0xad7746f6, 0x5ce506fe, 0x53b1ec0f, 0xcdde308b, 0x35cb742, 0x34b6f7c4, 0x9250fb10, 0xa6ec16d3, 0x15e7956a,
0xdba73d4f, 0x3acf6d8f, 0x904b66fc, 0x7d9c6e16, 0x59089040, 0x6727d98a, 0xba4e7db3, 0x5ed83902, 0x1b8171c5, 0xe29f2b46,
0xbe74a71b, 0xacd735f3, 0xc6e3741b, 0xca3ca96b, 0x5d8e22e8, 0xb32784c9, 0xf7b8308d, 0x5a087cc8, 0xe40381bb, 0xea0c5623,
0x22a34e61, 0x578317f0, 0x40fda307, 0xca1f01a, 0x5100d3e8, 0x97f2b063, 0x5ecb2a44, 0xcb8796b0, 0x7bd238bb, 0x9addb945,
0x6bd63075, 0x475676e0, 0xa2249968, 0x6f1332d9, 0x3c9fedd5, 0x28f54877, 0x97fe1482, 0xf70d622e, 0xb014bc49, 0xfabd3294,
0x73ef3d7e, 0x8fc34186, 0xfb880c54, 0x9d6ad911, 0x556b2de, 0x388babeb, 0x4f8965ce, 0xac1fcf0b, 0xba5bc70f, 0x23ddff1a,
0xb66935ab, 0x133c11f, 0xbe8d6643, 0x1ec54f6e, 0xf528e9a4, 0xdc865fa0, 0x9e4902a, 0x7d5d9b4c, 0xcf4de2bd, 0xef54a57e,
0x3acc1ea9, 0x76e527db, 0xc67f0159, 0x6d42e637, 0xd137a54f, 0x36a2eaf, 0x2c9918f6, 0x7493e65f, 0x157bf72b, 0xb40e85a0,
0x7145d891, 0xc09806b7, 0x75641bf3, 0xa3cbec89, 0xf18a723c, 0xd4173e08, 0xec945c4d, 0x3ffd6849, 0x1ca8f12f, 0x117bfe55,
0xf9b783d5, 0xd8451026, 0x48dbb458, 0xb688c8ad, 0x3107c0e3, 0x9854d3ae, 0xd06312bf, 0x31b1268b, 0x9a01445a, 0x947fbf55,
0x67c20e21, 0xd6cf925, 0x70daa280, 0xcd0420bc, 0x9be8826c, 0x9f67e13e, 0x3be5c9ed, 0x6330ddab, 0xa13484fc, 0x389d567c,
0x88402364, 0xa87af359, 0xb9344d26, 0x874acb17, 0x61917420, 0xa7ea701e, 0xe750c7, 0xef1ad1df, 0x18fac749, 0x8c38e39c,
0x5d07f9da, 0xc205f478, 0xb90f2dae, 0x14054bd0, 0xb895763f, 0xb28f2f44, 0xaaa77e6, 0xf46b569, 0x92aec261, 0x3a6ca5d5,
0x7fe151fc, 0xb48d9ef5, 0x19f429d4, 0x6c17360, 0xcf369529, 0xedc82951, 0x431f729f, 0x9712532a, 0x41a564d7, 0xee785b32,
0x8baa6b55, 0x55a6fece, 0x8ef15ed7, 0x1a8173e0, 0xddea3752, 0x7bbbf086, 0xc2048c1c, 0xdc18ca24, 0xac41f36, 0x85133b4c,
0xbc451db5, 0xb3ffa40d, 0xb7dcd96, 0xe33362a9, 0x6eeeb448, 0x9348fb87, 0xe45981a2, 0x6ddf9c7a, 0x668003ca, 0x2f5c3e22,
0x4db76600, 0xca9e16c5, 0x9cd22758, 0x265ac0e, 0x2ef8d2ba, 0x32f121ae
};
#else
int _packedBlueNoise32x32[1024] = {
0x99, 0xA7, 0xDA, 0xF5, 0x94, 0xC3, 0xD2, 0xE4, 0x8C, 0xF2, 0x23, 0x3B, 0xFD, 0x92, 0x6F, 0x09,
0xF8, 0x79, 0x39, 0x5F, 0x4E, 0xBE, 0xE7, 0x3D, 0x72, 0x12, 0x42, 0x69, 0x90, 0xC0, 0x5F, 0x49,
0xFB, 0x57, 0x39, 0xB1, 0x79, 0x4C, 0x17, 0x6E, 0x42, 0xA2, 0xD6, 0x77, 0x5A, 0x2C, 0xDA, 0x41,
0x89, 0xA6, 0x15, 0xE2, 0x2E, 0xD6, 0x7F, 0x28, 0xF2, 0x99, 0xB3, 0x52, 0x05, 0xD4, 0x11, 0x7C,
0x24, 0x6F, 0x10, 0x2C, 0xEA, 0x07, 0xAC, 0x83, 0xBF, 0x53, 0x09, 0xAF, 0x85, 0xE6, 0xBD, 0x21,
0xB2, 0xEB, 0xC3, 0x93, 0x75, 0x1C, 0xA4, 0x8C, 0x5B, 0xC8, 0x20, 0xDB, 0xEE, 0x87, 0x3E, 0xB9,
0x92, 0xE0, 0xD0, 0x8A, 0x62, 0x9B, 0xD9, 0x28, 0xFA, 0x1D, 0x98, 0xEE, 0x10, 0x4A, 0xA0, 0x64,
0x52, 0x01, 0x69, 0x46, 0xFF, 0xB0, 0x53, 0x08, 0xDF, 0x33, 0x7E, 0xA1, 0x71, 0x2C, 0xAA, 0xE7,
0x19, 0xBE, 0x50, 0x40, 0xC7, 0xF4, 0x58, 0x39, 0x76, 0x62, 0xC9, 0x34, 0x6C, 0xCD, 0x19, 0x7E,
0xD3, 0x35, 0x85, 0xCC, 0x0E, 0x3A, 0xED, 0xBF, 0x6D, 0x43, 0xFC, 0x16, 0x4B, 0xCC, 0x58, 0x68,
0x82, 0x02, 0xAA, 0x73, 0x1C, 0xB5, 0x0C, 0x91, 0xA8, 0xE0, 0x47, 0xB6, 0x8D, 0xF8, 0x3C, 0xE2,
0x97, 0xF6, 0xB8, 0x25, 0x9D, 0x63, 0xD0, 0x91, 0x13, 0xA9, 0x61, 0xC4, 0x96, 0x0A, 0xF4, 0x35,
0x47, 0xFA, 0x96, 0xE5, 0x31, 0x7C, 0x4A, 0xEB, 0xD1, 0x02, 0x80, 0x24, 0x5E, 0x06, 0xAB, 0x75,
0x2B, 0x13, 0x57, 0x70, 0xDE, 0x4A, 0x79, 0x2D, 0xB5, 0x84, 0xE9, 0x29, 0x8A, 0xB2, 0xDC, 0x9E,
0xC9, 0x5D, 0x26, 0xD6, 0x65, 0xA3, 0xC6, 0x18, 0x6A, 0x2F, 0xA0, 0xE8, 0xC1, 0x93, 0x4B, 0xC5,
0x60, 0xA1, 0xE9, 0xAF, 0x89, 0x04, 0xF3, 0x1E, 0xE1, 0x4E, 0x00, 0xD4, 0x3F, 0x6B, 0x20, 0x78,
0xEB, 0x3B, 0xB8, 0x09, 0x8F, 0xF8, 0x3D, 0x86, 0xBD, 0x51, 0xFD, 0x3F, 0x71, 0x1D, 0xDE, 0xF2,
0x0B, 0x41, 0xD5, 0x19, 0x36, 0xC6, 0xA6, 0x95, 0x5A, 0x37, 0xBC, 0x7A, 0xF0, 0x54, 0xC1, 0x11,
0xA8, 0x6F, 0x84, 0x52, 0x15, 0xCE, 0x5B, 0x21, 0xAF, 0x98, 0x12, 0xD7, 0xB1, 0x57, 0x33, 0x82,
0xBA, 0x8E, 0x79, 0x50, 0xF9, 0x68, 0x43, 0xD8, 0x72, 0xF6, 0x9A, 0x60, 0x0D, 0xA4, 0x31, 0x8E,
0xD1, 0x1D, 0xDC, 0xE9, 0xAD, 0x2D, 0x70, 0xEF, 0xDF, 0x78, 0x60, 0x88, 0x0B, 0xCE, 0x9D, 0x22,
0x67, 0xCC, 0x2D, 0x9B, 0xBB, 0x25, 0x80, 0x0A, 0xC3, 0x14, 0xAD, 0x25, 0x83, 0xE1, 0xFF, 0x4C,
0x2B, 0x65, 0x9A, 0x44, 0x7A, 0xC0, 0x9E, 0x04, 0x47, 0x36, 0xC4, 0x2A, 0xF6, 0x46, 0x77, 0xAD,
0xFE, 0x06, 0xE5, 0x5C, 0x0F, 0xEC, 0xB1, 0x53, 0x8B, 0x30, 0xDE, 0xCD, 0x42, 0xB7, 0x5C, 0x03,
0xC4, 0xF7, 0xB6, 0x34, 0x10, 0xFB, 0x50, 0x92, 0xD3, 0x16, 0xEC, 0xA6, 0x6A, 0x95, 0xE7, 0x15,
0x4F, 0x3D, 0xA7, 0xDB, 0x8F, 0x6D, 0xCF, 0x3A, 0xFC, 0x66, 0x4B, 0x90, 0x16, 0x6E, 0x9C, 0x7D,
0x40, 0x90, 0x08, 0x59, 0x8A, 0xD9, 0x27, 0x67, 0xB3, 0x7D, 0x4E, 0xBA, 0x02, 0x39, 0xD8, 0x5E,
0xC5, 0x71, 0x81, 0x1B, 0x46, 0x2B, 0x9F, 0xE2, 0x1B, 0xA7, 0x74, 0xBE, 0xF3, 0x35, 0xD7, 0xAC,
0x1B, 0x74, 0xE3, 0xC6, 0x6B, 0xA9, 0x3C, 0xCA, 0xE8, 0x22, 0x8E, 0x5D, 0xC9, 0x84, 0x27, 0xB3,
0x8D, 0x30, 0xB8, 0xF7, 0xC8, 0x7C, 0x08, 0x5A, 0xBB, 0x81, 0x03, 0xE4, 0x23, 0x56, 0x0C, 0xEA,
0x61, 0x4E, 0xA3, 0x22, 0xF0, 0x17, 0x83, 0x57, 0x07, 0xA3, 0xFD, 0x40, 0x1A, 0xF0, 0xA1, 0x0C,
0xE8, 0xD3, 0x00, 0x51, 0x63, 0xB0, 0xF2, 0x97, 0x44, 0x2A, 0xCB, 0x5E, 0xB0, 0x96, 0x87, 0xCB,
0xBB, 0x38, 0xD2, 0x7B, 0x45, 0xB9, 0xDD, 0x9A, 0x75, 0x30, 0xD6, 0x6B, 0xE0, 0x76, 0x56, 0x47,
0x68, 0x99, 0x24, 0xA2, 0xD9, 0x32, 0x13, 0x6F, 0xD5, 0xED, 0x9F, 0x3C, 0x77, 0x48, 0xF5, 0x28,
0x82, 0x14, 0xFE, 0x97, 0x2E, 0x62, 0x0D, 0xF7, 0x49, 0xBC, 0x14, 0xB0, 0x94, 0x32, 0xBD, 0xFA,
0x7E, 0x3D, 0xEF, 0x73, 0x86, 0x41, 0xC3, 0x8F, 0x54, 0x0C, 0x88, 0xFB, 0x11, 0xD9, 0x6A, 0x9D,
0xDE, 0xB2, 0x56, 0x05, 0xEB, 0xAB, 0x8B, 0x38, 0xCE, 0x65, 0x89, 0x4F, 0x0B, 0xCF, 0x1F, 0xAC,
0x0F, 0xC7, 0x5B, 0xBA, 0x1A, 0xFF, 0xDD, 0x23, 0xAB, 0x35, 0x69, 0xB6, 0x1F, 0xC1, 0x33, 0x01,
0x43, 0x66, 0x8D, 0xBE, 0x6E, 0x4F, 0xC5, 0x1E, 0xA4, 0xE9, 0x28, 0xF5, 0xA0, 0x5F, 0x86, 0xDC,
0x2A, 0x90, 0xE4, 0x09, 0x4C, 0x9B, 0x5D, 0x7D, 0xBD, 0xE2, 0x4D, 0xCF, 0x7E, 0xA5, 0x54, 0xEF,
0xA9, 0x1E, 0xCC, 0x3A, 0xDB, 0x27, 0xE5, 0x76, 0x59, 0x01, 0x7F, 0xC6, 0x37, 0xE6, 0x42, 0x6D,
0x4F, 0xA5, 0x37, 0xD1, 0xAF, 0x2E, 0x6A, 0x03, 0xF6, 0x18, 0x99, 0x2C, 0x5F, 0xE6, 0x93, 0x74,
0x2B, 0xF7, 0x7B, 0x15, 0xA0, 0x85, 0x0E, 0xB4, 0x91, 0xD8, 0x45, 0x71, 0xB7, 0x06, 0x98, 0xC0,
0xF3, 0x1B, 0x64, 0x75, 0x89, 0xEC, 0xCB, 0xA3, 0x3C, 0x72, 0x8A, 0xF1, 0x08, 0x3E, 0x17, 0xD4,
0x4D, 0x5C, 0x94, 0xEC, 0x49, 0x68, 0xFD, 0x3F, 0x2F, 0xF1, 0xA8, 0x1C, 0x55, 0xFE, 0x7B, 0x11,
0xD5, 0x83, 0xB7, 0xF9, 0x26, 0x10, 0x45, 0xD8, 0x58, 0xB4, 0xDB, 0x48, 0xAD, 0xC8, 0x88, 0xB6,
0xE3, 0xC0, 0x07, 0x31, 0xAE, 0xD3, 0x54, 0x98, 0xBF, 0x12, 0x63, 0xD0, 0x8B, 0x26, 0xB1, 0x31,
0x5A, 0x44, 0x01, 0x9A, 0x55, 0xBF, 0x7F, 0x94, 0x21, 0x0E, 0xC2, 0x67, 0x25, 0xF9, 0x6C, 0x0D,
0x80, 0xA2, 0xDA, 0x70, 0xBC, 0x20, 0x04, 0xCD, 0x6C, 0x82, 0xE8, 0x9B, 0x3E, 0xE1, 0x67, 0x9F,
0xED, 0xC9, 0xE5, 0x3B, 0xAB, 0xDD, 0x30, 0x63, 0xFC, 0x84, 0x34, 0xA1, 0x7C, 0x56, 0x9D, 0x38,
0x64, 0x23, 0x40, 0x88, 0x59, 0xF3, 0x7A, 0xA8, 0x26, 0x4D, 0x34, 0xB9, 0x17, 0xCB, 0x4A, 0x87,
0x20, 0x74, 0x91, 0x61, 0x1E, 0x70, 0xEA, 0xA7, 0xC7, 0x50, 0xE7, 0x00, 0xDF, 0xD1, 0x1A, 0xEF,
0x49, 0xC7, 0xFA, 0x18, 0x9C, 0xE3, 0x38, 0x8C, 0xDA, 0xF9, 0x07, 0x5D, 0x78, 0xF4, 0x05, 0xC2,
0xAE, 0x2D, 0x0F, 0xB9, 0xD0, 0x4B, 0x05, 0x14, 0x3F, 0x76, 0x95, 0xB8, 0x44, 0x2F, 0x8F, 0xB2,
0xE6, 0x77, 0xAA, 0x0A, 0x69, 0xB5, 0x46, 0x0F, 0x61, 0xC2, 0xAE, 0x92, 0xD5, 0xA5, 0x6C, 0x3A,
0xFC, 0x51, 0xE1, 0x7F, 0xF5, 0x9E, 0x8D, 0xB4, 0xD4, 0x29, 0xF4, 0x19, 0x60, 0x73, 0xC1, 0x06,
0x29, 0x95, 0x36, 0xCF, 0x51, 0x29, 0xC8, 0xED, 0x9F, 0x72, 0x1F, 0x43, 0x2A, 0x53, 0x12, 0x97,
0xD7, 0x64, 0xA5, 0x41, 0x32, 0x5B, 0x78, 0xEE, 0x55, 0x6B, 0xAA, 0x8B, 0xCE, 0xFE, 0xA6, 0x55,
0xD7, 0x5E, 0xF1, 0x8E, 0xE0, 0x73, 0x81, 0x1A, 0x52, 0x37, 0xEA, 0xDD, 0x86, 0xF0, 0xBB, 0x7B,
0x1C, 0x8C, 0x04, 0xC2, 0x24, 0xCA, 0x18, 0xDC, 0x36, 0x1F, 0xC4, 0x0A, 0x4C, 0x3B, 0x13, 0x85,
0xB5, 0x1D, 0x45, 0xBC, 0x0D, 0xA4, 0xFF, 0xB3, 0x96, 0xCD, 0x7D, 0x0B, 0xA9, 0x62, 0x33, 0xE3,
0x48, 0xB4, 0xEE, 0x6E, 0x87, 0xFB, 0x48, 0x93, 0xA2, 0x81, 0x59, 0xE4, 0x7A, 0x9C, 0xDF, 0x6D,
0xCA, 0x03, 0x80, 0x66, 0x22, 0x3E, 0x5C, 0x2F, 0x00, 0x66, 0xB7, 0x4D, 0xC5, 0x16, 0x9E, 0xCA,
0x58, 0x27, 0xD2, 0x9C, 0x0E, 0xAC, 0x65, 0x02, 0xBA, 0xD2, 0xF8, 0x2E, 0xAE, 0x21, 0xF1, 0x32};
#endif

/// returns a [0,1] value of tileable 32x32 blue noise
float blueNoise32x32(ivec2 xy) {
#ifdef USE_PACKED_BLUE_NOISE
    int index1D = (xy.x % 32) + (xy.y % 32)*32;
    int val = (_packedBlueNoise32x32[index1D / 4] >> ((index1D % 4)*8)) & 0xFF;
    return float(val)/255.f;
#else
    return float(_packedBlueNoise32x32[(xy.x % 32) + (xy.y % 32)*32])/255.f;
#endif
}

/// returns a [0,255] value of tileable 32x32 blue noise
uint blueNoise32x32_uint8(uvec2 xy) {
#ifdef USE_PACKED_BLUE_NOISE
    uint index1D = (xy.x % 32u) + (xy.y % 32u)*32u;
    return uint(_packedBlueNoise32x32[index1D / 4u] >> ((index1D % 4u) * 8u)) & 0xFF;
#else
    return uint(_packedBlueNoise32x32[(xy.x % 32u) + (xy.y % 32u)*32u]);
#endif
}

float _perlinFade(float v) {
    return v * v * v * (v * (v * 6.f - 15.f) + 10.f);
}

float _perlinNoise(vec2 uv, uint repeat_freq) {
    uvec2 cell = uvec2(uv);
    vec2 ab = fract(uv);

    const vec2 ofst[] = vec2[](vec2(0.f, 0.f), vec2(1.f, 0.f), vec2(0.f, 1.f), vec2(1.f, 1.f));
    float v[4];
    for (int i = 0; i < 4; i++)
        v[i] = dot(randomDirection2((cell + uvec2(ofst[i])) % repeat_freq), ab - ofst[i]);

    return mix(mix(v[0], v[1], _perlinFade(ab.x)), mix(v[2], v[3], _perlinFade(ab.x)), _perlinFade(ab.y));
}

float perlinNoise(vec2 uv, int octaves) {
    // fractal brownian motion
    float v = 0.f;

    float amp = 2.f;
    uint freq = 2u;
    for (int o = 0; o < octaves; o++) {
        v += amp * _perlinNoise(uv * float(freq), freq);

        amp *= 0.6f;
        freq *= 2u;
    }

    return 0.5f + 0.5f * v;
}


#endif // RANDOM_GLSL
