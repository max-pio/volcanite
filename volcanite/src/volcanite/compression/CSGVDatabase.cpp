//  Copyright (C) 2024, Max Piochowiak and Fabian Schiekel, Karlsruhe Institute of Technology
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include "volcanite/compression/CSGVDatabase.hpp"

#include "SQLiteCpp/VariadicBind.h"
#include <SQLiteCpp/SQLiteCpp.h>

namespace volcanite {

/// Exports preprocessing results to a new database after which it is opened in read mode.
bool CSGVDatabase::databaseExportAndOpen(const std::string &sqlite_path, const std::vector<uint32_t> &index_to_label,
                                         const glm::uvec3 volume_dimension, const glm::uvec3 chunk_dimension,
                                         const std::string &attribute_database, std::string attribute_table,
                                         const std::string &attribute_csv_separator,
                                         std::string label_column) {
    if (m_db) {
        Logger(Warn) << "closing existing csgv database " << m_db->getFilename() << " before creation";
        close();
    }

    MiniTimer t;
    try {
        std::string csgv_label_name = label_column.empty() ? "label" : label_column;
        SQLite::Database db(sqlite_path, SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE);
        // store general volume info in a single row in the CSGV_INFO_TABLE
        {
            db.exec("CREATE TABLE " + CSGV_INFO_TABLE +
                    " (volume_width INTEGER, volume_height INTEGER, volume_depth INTEGER, chunk_width INTEGER, chunk_height INTEGER, chunk_depth INTEGER, label_column TEXT)");
            SQLite::Statement query(db, "INSERT INTO " + CSGV_INFO_TABLE + " VALUES (?, ?, ?, ?, ?, ?, ?)");
            SQLite::bind(query, volume_dimension[0], volume_dimension[1], volume_dimension[2],
                         chunk_dimension[0], chunk_dimension[1], chunk_dimension[2], csgv_label_name);
            if (query.exec() != 1)
                Logger(Warn) << "Could not export " + CSGV_INFO_TABLE + " to sqlite";
        }

        // store mapping of original volume label <> packed csgv ids in a temporary table [CSGV_ATTRIBUTE_TABLE]_tmp
        {
            db.exec("CREATE TABLE " + CSGV_ATTRIBUTE_TABLE + "_tmp (" + ID_COLUMN + " UNSIGNED INT PRIMARY KEY, " + csgv_label_name + " UNSIGNED INT UNIQUE)");

            SQLite::Transaction transaction(db);
            SQLite::Statement query(db, "INSERT INTO " + CSGV_ATTRIBUTE_TABLE + "_tmp VALUES (?, ?)");
            for (uint32_t i = 0u; i < index_to_label.size(); i++) {
                SQLite::bind(query, i, index_to_label[i]);
                if (query.exec() != 1)
                    Logger(Warn) << "Could not insert entry for label into sqlite database";
                query.reset();
            }
            transaction.commit();
        }

        Logger(Debug) << "  exported label remapping to database " << sqlite_path << " in " << t.restart() << " seconds";

        // There are no attributes so we just use the label remapping table (2 columns) without any additional data
        if (attribute_database.empty()) {
            db.exec("ALTER TABLE " + CSGV_ATTRIBUTE_TABLE + "_tmp RENAME TO " + CSGV_ATTRIBUTE_TABLE);
        }
        // Join the label re-mapping in [CSGV_ATTRIBUTE_TABLE]_tmp attributes with an existing attribute database
        else {
            // Existing "database" is a .csv file: convert into sqlite table attr_db
            if (attribute_database.ends_with(".csv")) {
                std::vector<std::string> attribute_names;
                int label_column_index = -1;
                std::vector<unsigned int> label_columns_values = csv_label_column_import(attribute_database, attribute_csv_separator, label_column);
                std::vector<std::vector<float>> csv_database = csv_float_import(attribute_database, attribute_csv_separator, attribute_names);

                db.exec("ATTACH DATABASE ':memory:' AS attr_db"); // in-memory only database (no file)
                std::ostringstream create_table_sql_csv;
                std::ostringstream insert_sql_csv;

                attribute_table = IN_MEMORY_TABLE;
                // create net table for csv attributes with autogenerated primary key 'id'
                create_table_sql_csv << "CREATE TABLE attr_db." << attribute_table << "(";

                insert_sql_csv << "INSERT INTO attr_db." << attribute_table << "(";
                {
                    // read attribute names
                    bool first_column = true;
                    for (int attribute_idx = 0; attribute_idx < attribute_names.size(); attribute_idx++) {
                        if (attribute_names[attribute_idx] == label_column)
                            label_column_index = attribute_idx;
                        if (!first_column)
                            create_table_sql_csv << ", ";

                        // check what data type the column has by looking at all values
                        bool is_float = false;
#pragma omp parallel for default(none) shared(csv_database, attribute_idx, attribute_names, is_float)
                        for (auto & i : csv_database) {
                            if (is_float)
                                continue;
                            float val_temp = i[attribute_idx];
                            if (val_temp != std::floor(val_temp)) {
                                is_float = true;
                            }
                        }

                        if (attribute_idx == label_column_index)
                            create_table_sql_csv << attribute_names[attribute_idx] << " UNSIGNED INT PRIMARY KEY";
                        else
                            create_table_sql_csv << attribute_names[attribute_idx] << (is_float ? " REAL" : " INTEGER");

                        if (!first_column)
                            insert_sql_csv << ", ";
                        insert_sql_csv << attribute_names[attribute_idx];
                        first_column = false;
                    }
                    create_table_sql_csv << ");";

                    db.exec("DROP TABLE IF EXISTS attr_db." + attribute_table);
                    db.exec(create_table_sql_csv.str());
                    // write insert query values
                    insert_sql_csv << ") VALUES (";
                    first_column = true;
                    for (int i = 0; i < csv_database[0].size(); i++) {
                        if (!first_column)
                            insert_sql_csv << ", ";
                        insert_sql_csv << "?";
                        first_column = false;
                    }
                    insert_sql_csv << ");";

                    SQLite::Transaction transaction_csv(db);
                    SQLite::Statement query(db, insert_sql_csv.str());

                    int row_index = 0;
                    for (const auto &row : csv_database) {
                        int index = 1;

                        for (const auto &value : row) {
                            // TODO can this be rewrite to use SQL::bind? -> unified usage of bind method
                            if (index - 1 == label_column_index)
                                query.bind(index++, label_columns_values[row_index++]);
                            else
                                query.bind(index++, value);
                        }

                        if (query.exec() != 1)
                            Logger(Warn) << "Could not insert entry for label into sqlite database";
                        query.reset();
                    }
                    transaction_csv.commit();
                }
            }
            // existing database is already sqlite: attach it as attr_db
            else {
                db.exec("ATTACH DATABASE '" + attribute_database + "' AS attr_db");
            }

            // if not attribute table or label column was specified, we use the first table and its primary key
            if (attribute_table.empty() || label_column.empty()) {

                if (attribute_table.empty()) {
                    attribute_table = db.execAndGet("SELECT name FROM attr_db.sqlite_master WHERE type='table'").getString();
                    if (attribute_table.empty())
                        throw std::runtime_error("Could not find any table to use in attribute database. Provide attribute table and label column name with the attribute database.");
                }

                SQLite::Statement pk_query(db, "SELECT l.name FROM pragma_table_info('" + attribute_table + "','attr_db') as l WHERE l.pk = 1");
                if (!pk_query.executeStep()) {
                    throw std::runtime_error("Could not find any primary key in table '" + attribute_table + "'. Provide attribute table and label column name with the attribute database.");
                }
                label_column = pk_query.getColumn(0).getString();
                Logger(Debug) << "  using attribute table '" << attribute_table << "' with primary key label column '" << label_column << "'";
            }

            // 0. check if the provide label column only contains unique elements
            {
                SQLite::Statement check_duplicates(db,
                                                   "SELECT " + label_column + ", COUNT(*) AS cnt FROM attr_db." +
                                                       attribute_table + " GROUP BY " + label_column +
                                                       " HAVING cnt > 1");
                if (check_duplicates.executeStep())
                    throw SQLite::Exception(
                        "Label column " + label_column + " in " + attribute_database + " : " + attribute_table +
                        " contains forbidden duplicate entries.");
            }

            // 1. read all column names and types except the LABEL column from attribute file as a comma separated string
            std::vector<std::string> attr_col_names;
            std::vector<std::string> attr_col_types;
            {
                SQLite::Statement column_query(db, "SELECT name, type FROM pragma_table_info('" + attribute_table +
                                                       "','attr_db') ORDER BY cid");
                while (column_query.executeStep()) {
                    std::string c = column_query.getColumn(0).getString();
                    if (!std::equal(c.begin(), c.end(), label_column.begin(), label_column.end(),
                                    [](const char a, const char b) { return tolower(a) == tolower(b); })) {
                        attr_col_names.push_back(c);
                        attr_col_types.push_back(column_query.getColumn(1));
                    }
                }
            }

            // 2. create the final attribute table and populate it with a join of the _tmp label remapping table and the provided attribute database
            {
                // create an index on the label column in the databases if there are many labels
                bool created_index_on_attached_db = false;
                if (index_to_label.size() >= 65536) {
                    db.exec("CREATE UNIQUE INDEX csgv_label_index ON " + CSGV_ATTRIBUTE_TABLE + "_tmp(" +
                            csgv_label_name + ")");
                    try {
                        // attention! this creates an index in the ATTACHED database. We will drop it later.
                        db.exec("CREATE UNIQUE INDEX attr_db.csgv_label_index ON " + attribute_table + "(" +
                                label_column + ")");
                        created_index_on_attached_db = true;
                    } catch (SQLite::Exception) {
                        Logger(Warn) << "  could not create index on attached database " << attribute_database;
                    }
                    Logger(Debug) << "  created indices on databases in " << t.restart() << " seconds";
                }

                std::stringstream create_table_ss;
                create_table_ss << "CREATE TABLE " << CSGV_ATTRIBUTE_TABLE
                                << " (" + ID_COLUMN + " UNSIGNED INT PRIMARY KEY, " + csgv_label_name +
                                       " UNSIGNED INT UNIQUE, ";
                std::stringstream insert_ss;
                insert_ss << "INSERT INTO " << CSGV_ATTRIBUTE_TABLE << " SELECT " << ID_COLUMN << ", "
                          << CSGV_ATTRIBUTE_TABLE << "_tmp." << csgv_label_name << " AS " << csgv_label_name
                          << ", ";
                for (int i = 0; i < attr_col_names.size(); i++) {
                    create_table_ss << attr_col_names[i] << " " << attr_col_types[i] << ", ";
                    insert_ss << attr_col_names[i] << ", ";
                }
                // remove trailing ', '
                std::string create_table_str = create_table_ss.str();
                std::string insert_str = insert_ss.str();
                if (!attr_col_names.empty()) {
                    create_table_str.pop_back();
                    create_table_str.pop_back();
                    insert_str.pop_back();
                    insert_str.pop_back();
                }
                create_table_str.append(")");
                insert_str.append(
                    " FROM " + CSGV_ATTRIBUTE_TABLE + "_tmp LEFT JOIN attr_db." + attribute_table + " ON " +
                    CSGV_ATTRIBUTE_TABLE + "_tmp." + csgv_label_name + " = " + "attr_db." + attribute_table +
                    "." + label_column);

                SQLite::Transaction transaction(db);
                db.exec(create_table_str);
                db.exec(insert_str);
                db.exec("DROP TABLE " + CSGV_ATTRIBUTE_TABLE + "_tmp");
                transaction.commit();

                // remove temporary index from attached database
                if (created_index_on_attached_db) {
                    try {
                        db.exec("DROP INDEX IF EXISTS attr_db.csgv_label_index");
                    } catch (SQLite::Exception) {
                        Logger(Warn) << "Could not drop index csgv_label_index from attached database "
                                     << attribute_database;
                    }
                }
            }

            Logger(Debug) << "  import attributes from existing database " << attribute_database << " in " << t.restart() << " seconds";
            db.exec("DETACH DATABASE attr_db");
        }
    } catch (const SQLite::Exception &e) {
        // remove broken database file and forward the exception
        if (std::filesystem::exists(sqlite_path))
            std::filesystem::remove(sqlite_path);
        throw std::runtime_error(std::string("SQLite error: ") + e.what());
    }

    // reimport database as read only
    importFromSqlite(sqlite_path);
    return true;
}

void CSGVDatabase::importFromSqlite(const std::string &sqlite_path) {
    m_db = new SQLite::Database(sqlite_path, SQLite::OPEN_READONLY);

    // read label count, attribute names, and min/max values from columns
    m_label_count = m_db->execAndGet("SELECT COUNT(*) FROM " + CSGV_ATTRIBUTE_TABLE).getInt64();
    m_attribute_names.clear();
    m_attribute_minmax.clear();
    SQLite::Statement column_query(*m_db, "SELECT name FROM pragma_table_info('" + CSGV_ATTRIBUTE_TABLE + "') ORDER BY cid");
    while (column_query.executeStep()) {
        m_attribute_names.push_back(column_query.getColumn(0).getString());
        m_attribute_minmax.emplace_back(static_cast<float>(m_db->execAndGet("SELECT MIN(" + m_attribute_names.back() + ") FROM " + CSGV_ATTRIBUTE_TABLE).getDouble()),
                                        static_cast<float>(m_db->execAndGet("SELECT MAX(" + m_attribute_names.back() + ") FROM " + CSGV_ATTRIBUTE_TABLE).getDouble()));
    }
}

void CSGVDatabase::processVolumeAndCreateSqlite(const std::string &sqlite_export_path,
                                                const std::string &volume_input_path,
                                                const std::string &attribute_database,
                                                const std::string &attribute_table,
                                                const std::string &label_column,
                                                const std::string &attribute_csv_separator,
                                                bool chunked_input_data, glm::uvec3 max_file_index) {

    // this function computes volume dimensions and the index_to_label re-mapping that will be applied to the volume
    // and then calls databaseExportAndOpen to join it with the attribute database

    std::shared_ptr<Volume<uint32_t>> volume = nullptr;
    std::unordered_set<uint32_t> label_set = {}; // hash set to speed up the {label already exists} check
    std::vector<uint32_t> index_to_label = {};

    MiniTimer t;
    // iterate over all chunk files in morton order
    bool chunk_dimensions_vary = false;
    size_t chunk_index1D = 0ul;
    glm::uvec3 chunk_index(0ul);
    glm::uvec3 volume_dimension(0u);
    glm::uvec3 chunk_dimension(0u);
    do {
        chunk_index = sfc::Morton3D::i2p(chunk_index1D);
        if (glm::all(glm::lessThanEqual(chunk_index, max_file_index))) {
            // create file input path for this single chunk
            std::string chunk_input_path = chunked_input_data ? formatChunkPath(volume_input_path,
                                                                                static_cast<int>(chunk_index.x),
                                                                                static_cast<int>(chunk_index.y),
                                                                                static_cast<int>(chunk_index.z))
                                                              : volume_input_path;
            // load chunk volume
            Logger(Debug, true) << "  label preprocessing " << chunk_input_path << " "
                                << (1 + sfc::Cartesian::p2i(chunk_index, max_file_index + glm::uvec3(1))) << "/" << (1 + sfc::Cartesian::p2i(max_file_index, max_file_index + glm::uvec3(1)));

            CompSegVolHandler::loadSegmentationVolumeFile(chunk_input_path, volume);
            glm::uvec3 cur_chunk_dim(volume->dim_x, volume->dim_y, volume->dim_z);

            // process chunk volume
            if (chunk_index1D == 0ul) {
                chunk_dimension[0] = cur_chunk_dim.x;
                chunk_dimension[1] = cur_chunk_dim.y;
                chunk_dimension[2] = cur_chunk_dim.z;
            } else if (chunk_dimension[0] != cur_chunk_dim.x || chunk_dimension[1] != cur_chunk_dim.y || chunk_dimension[2] != cur_chunk_dim.z) {
                chunk_dimensions_vary = true;
            }

            // update tracking information
            volume_dimension[0] += cur_chunk_dim.x;
            volume_dimension[1] += cur_chunk_dim.y;
            volume_dimension[2] += cur_chunk_dim.z;

            // process chunk: iterate over all voxels in morton order, add them to the existing_labels set and
            // the index_to_label vector if they did not occur before.
            {
                const uint64_t last_i = sfc::Morton3D::p2i_64(cur_chunk_dim);
                constexpr int NUM_THREADS = 8;
                size_t voxels_per_thread = (32ul * 32ul * 32ul);
                // parallel processing will only have a benefit if we can run at least 4 threads in parallel
                if (last_i < 4ul * voxels_per_thread) {
                    voxels_per_thread = last_i;
                    // NUM_THREADS = 1;
                }

                // iterate over all voxels in the volume to create a list of unique labels
                // we first store the labels in a thread-private _index_to_label and gather them later in the global map
                std::vector<uint32_t> _index_to_label[NUM_THREADS];
                std::unordered_set<uint32_t> _label_set[NUM_THREADS];

                for (auto &v : _index_to_label)
                    v.reserve(voxels_per_thread);
                for (size_t i = 0; i < last_i; i += (NUM_THREADS * voxels_per_thread)) {
// process the next NUM_THREADS * voxels_per_thread count voxels in parallel
#pragma omp parallel num_threads(NUM_THREADS) default(none) shared(i, voxels_per_thread, cur_chunk_dim, volume, label_set, _index_to_label, _label_set)
                    {
                        unsigned int thread_id = omp_get_thread_num();
                        _index_to_label[thread_id].clear();
                        _label_set[thread_id].clear();

                        for (uint64_t n = i + thread_id * voxels_per_thread; n < i + (thread_id + 1) * voxels_per_thread; n++) {
                            glm::uvec3 voxel = sfc::Morton3D::i2p_64(n);
                            if (glm::all(glm::lessThan(voxel, cur_chunk_dim))) {
                                uint32_t label = volume->getElement(voxel);
                                if (!_label_set[thread_id].contains(label) && !label_set.contains(label)) {
                                    _index_to_label[thread_id].push_back(label);
                                    // we can not add the label to the global label set here, because it may create duplicate entries
                                    _label_set[thread_id].insert(label);
                                }
                            }
                        }
                    }

                    // gather all thread-private label sets into the global map
                    for (int thread_id = 0; thread_id < NUM_THREADS; thread_id++) {
                        for (const auto &label : _index_to_label[thread_id]) {
                            if (!label_set.contains(label)) {
                                index_to_label.push_back(label);
                                label_set.insert(label);
                            }
                        }
                    }

                    if (i % (last_i / 100) == 0u)
                        Logger(Info, true) << " re-labelling map computation " << static_cast<int>(static_cast<float>(i) / static_cast<float>(last_i) * 100.f) << "%";
                }

                if (index_to_label.size() != label_set.size())
                    throw std::runtime_error("existing_labels set does not match index_to_label size in volume label occurrence processing");
            }
        }

        chunk_index1D++;
    } while (chunked_input_data && glm::any(glm::lessThanEqual(chunk_index, max_file_index)));

    if (chunk_dimensions_vary)
        Logger(Warn) << "  chunk dimensions vary and can differ from expected dimension " << str(chunk_dimension);

    Logger(Debug) << "  computed label remapping in " << t.elapsed() << " seconds with " << index_to_label.size() << " unique labels";

    // create new SQLite database, export all data and then re-import as read only
    databaseExportAndOpen(sqlite_export_path, index_to_label, volume_dimension, chunk_dimension,
                          attribute_database, attribute_table, attribute_csv_separator, label_column);
}

[[nodiscard]] std::shared_ptr<std::unordered_map<uint32_t, uint32_t>> CSGVDatabase::getLabelRemapping() const {
    if (!m_db)
        throw std::runtime_error("No CSGV sqlite database present.");

    // clear the label_to_index map and reserve memory
    const std::string label_column_name = m_db->execAndGet("SELECT label_column FROM " + CSGV_INFO_TABLE).getString();
    const uint32_t columns = m_db->execAndGet("SELECT COUNT(*) FROM " + CSGV_ATTRIBUTE_TABLE).getUInt();
    auto label_to_index = std::make_shared<std::unordered_map<uint32_t, uint32_t>>();
    label_to_index->reserve(columns);

    // fill the map with entries for all labels
    SQLite::Statement query(*m_db, "SELECT " + ID_COLUMN + ", " + label_column_name + " FROM " + CSGV_ATTRIBUTE_TABLE);
    const int id_column = query.getColumnIndex(ID_COLUMN.c_str());
    const int label_column = query.getColumnIndex(label_column_name.c_str());
    while (query.executeStep())
        (*label_to_index)[query.getColumn(label_column)] = query.getColumn(id_column);

    return label_to_index;
}

size_t CSGVDatabase::getAttribute(const int attributeIndex, float *begin, const size_t maxSize) {
    if (!m_db)
        throw std::runtime_error("No CSGV attribute database present.");

    if (attributeIndex >= m_attribute_names.size())
        throw std::runtime_error("invalid attribute index " + std::to_string(attributeIndex));
    if (maxSize < m_label_count)
        throw std::runtime_error("Buffer for attribute " + m_attribute_names[attributeIndex] + "(" + std::to_string(attributeIndex) + ") does not fit " + std::to_string(m_label_count) + " elements.");

    SQLite::Statement query(*m_db, "SELECT " + m_attribute_names[attributeIndex] + " FROM " + CSGV_ATTRIBUTE_TABLE + " ORDER BY " + ID_COLUMN);
    float *it = begin;
    while (query.executeStep()) {
        *it = static_cast<float>(query.getColumn(0).getDouble());
        it++;
    }
    assert((it == begin + m_label_count) && "Did not write expected number of attribute values");
    return (it - begin);
}

void CSGVDatabase::close() {
    if (m_db) {
        delete m_db;
        m_db = nullptr;
    }
    m_attribute_names.clear();
    m_attribute_minmax.clear();
    m_label_count = 0;
}
} // namespace volcanite